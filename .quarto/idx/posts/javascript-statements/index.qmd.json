{"title":"JavaScript Statements","markdown":{"yaml":{"title":"JavaScript Statements","author":"Maya Gans","date":"2019-08-02","description":"Statements aren't functions? Explaining the different and walking through some different JavaScript statements.","categories":["JavaScript"],"image":"featured.png"},"headingText":"If","containsRefs":false,"markdown":"\n\nComputers are awesome for their ability to execute instructions. I mean, do you want to perform repetitive, error prone, menial tasks? Personally, I don't want to spend time processing data, I just want to analyze it and eventually make pretty graphs. To do this though, the computer needs instructions, and these instructions come in the form of a list of **statements**. In this post I want to go over the grammar of JavaScript statements. Only by familiarizing ourselves with the entire toolbox of statement options can we efficiently boss the computer around exactly how we intend to.\n\n\nWe can use the `if` statement to run a function when an argument is true\n\n```\nvar happy = TRUE\nvar knowIt = TRUE\n\nif (happy == TRUE && knowIt == TRUE) {\n  clapYourHands = TRUE\n}\n\nconsole.log(clapYourHands)\n```\n\n```\nTRUE\n```\n\nIf you're Happy AND you know it, clapYourHands == TRUE.\n\n\n## Then\n\nIn the code block above the curly brackets could be understood as `then`. Translating the block above into plain English: if `happy` and `knowIt` are both true `then` set clapYourHands to true.\n\n## Else\n\nBut what if I want to set clapYourHands to `false` if you're not happy? `else` gives us the ability to assign a different argument to `clapYourHands` if it fails the `then` test [here `(happy == TRUE && knowIt == TRUE)`]\n\n```\nvar happy = false\nvar knowIt = true\n\nif (happy === true && knowIt === true) {\n  clapYourHands = true\n} else {\n  clapYourHands = false\n}\n\nconsole.log(clapYourHands)\n```\n\n```\nTRUE\n```\n\n## Switch - Case - Break\n\nIn the example above `happy` and `knowIt` are binary, but the human gamut of emotions is far more complex than happy or not. This is where `switch` comes in. Rather than writing a long chain of {`if` this `else if` this other thing `else if` even more stuff `else` the default} we can just invoke a `switch` statement with multiple `cases`!\n\n```\nvar emotion = \"disinterested\"\nvar clapYourHands = []\n\nswitch(emotion) {\n  case 'happy':\n    clapYourHands = true\n    break;\n  case 'sad':\n    clapYourHands = false\n    break;\n    // default = what to do when no cases match\n  default:\n    clapYourHands = \"Can't be sure\"\n}\n\nconsole.log(clapYourHands)\n```\n\n```\n\"Can't be sure\"\n```\n\nThe `switch` statement goes through all the cases, trying to find a match for `emotion`. Once it finds a matching `case`, it applies the associated argument [here `case = default`;`clapYourHands = \"Can't be sure\"`]. \n\nI also snuck in the `break` keyword because this is what gets us out of the `switch` block. By using `break` we're saying - *if this `case` is a match just use it, be done with the `switch` and move on with your life*. Note that we don't need to `break` the last statement in a `switch`, the computer knows it's exhausted all options at that point.\n\n## For\n\nNo one ever wanted to be that solitary person clapping. Instead of using `switch` to evaluate a single `emotion`, we can use a `for` loop to assess all the emotions of our friends in the room, then gauge how many people are clapping.\n\n\n```\n// create an array to capture the emotions in the room\nvar emotions = [\"disinterested\", \"happy\", \"sad\", \"happy\", \"dispondent\", \"happy\"]\n\n// this empty array will store the loop values\nvar whosClapping = []\n\nfor (i = 0; i < emotions.length; i++) { \n\n  switch(emotions[i]) {\n    case 'happy':\n      var clapYourHands = true\n      break;\n    case 'sad':\n      clapYourHands = false\n      break;\n    default:\n      clapYourHands = \"Can't be sure\"\n    }\n\n  whosClapping[i] = clapYourHands\n\n}\n\nconsole.log(whosClapping)\nconsole.log(whosClapping == true)\n```\n\n```\n[ 'Can't be sure', true, false, true, 'Can't be sure', true ]\n```\n\na `for` loop begins with a counter, we're calling it `i` and setting it to zero. The next argument is how many times you want the computer to run through the loop. Rather than count up the number of elements in our array in our heads and provide `6`, we make the computer do the work for us! `array.length` gives back the number of elements in an array. `i++` is shorthand to increment `i` by 1 as we progress through the loop.\n\nThe only difference in our switch within the loop is rather than reference `emotion`, we reference `emotions[i]`. For each turn through the loop the computer will evaluate the switch on the `i`th value within `emotions`\n\nBefore we let the computer move onto the next loop, we store the current iteration's value for `clapYourHands` within the `whosClapping` array. `whosClapping[0]` will be the `clapYourHands` value for `emotions[0]` until the computer makes it through all 6 values within `emotion`.\n\n## While\n\nIf your friends aren't responding when you ask them if you're happy, we can make all 6 of them clap using a `while` loop.\n\nLike the `for` loop, a `while` loop also repeats until a condition changes. Unlike a `for` loop, we set a condition and loop through until the condition is no longer met [the opposite is true of a `for` loop where each time it runs the condition is looked for.]\n\n```\nvar happy = 0\n\nwhile(happy < 6) {\n  console.log(\"clap your hands\")\n  i++\n}\n```\n\n```\nclap your hands\nclap your hands\nclap your hands\nclap your hands\nclap your hands\nclap your hands\n```\n\nWe set our iterator to zero outside of the loop, then use the condition `happy < 6` to run our loop 6 times.\n\n## Do\n\nThe `do` loop is like the `while` loop but backwards. First the loop is executed, and the condition comes after the body\n\n```\nvar happy = 0\n\ndo { \n  console.log(\"clap your hands\")\n  happy ++\n} while(happy < 6);\n```\n\n```\nclap your hands\nclap your hands\nclap your hands\nclap your hands\nclap your hands\nclap your hands\n```\n\nWithin our `do` statement which gets everyone to clap, we also increment happy. The loop is executed until we reach happy == 6\n\n## Return\n\nWhen you write a function, `return` stops the function execution and returns the value \n\n```\nfunction clapping(name) {\n  return name + \" is happy, and knows it\";\n}\n\nvar maya = clapping(\"Maya\")\nconsole.log(maya)\n```\n\n```\nMaya is happy, and knows it\n```\n\nWe save the results of the function `clapping('Maya')` within a new variable, `maya` which is stored in memory, then use `console.log` to print the new variable. *If we didn't print `maya` to the console we'd only know the code ran because we didn't get an error (silence is golden).*\n\n## Throw\n\nThe `throw` statement looks at an input and if it is wrong, creates a custom error message.\n\n```\nfunction getClappers(i) {\n\n  if (i > 0) {\n    return \"Someone is happy\";\n  } else {\n    throw 'No one is happy';\n  }\n}\n\nconsole.log(getClappers(0))\n```\n\n```\nNo one is happy\n```\n\n## Try - Catch \n\n`try...catch` statements are used to catch errors, an inevitable part of programming that should be embraced early. We'll demonstrate this using our `getClappers` function where rather than have the code stop running because no one is clapping, we'll use `catch` to create a string stored in the variable `happy`.\n\n```\nvar happy = []\ntry {\n  happy = getClappers(0)\n}\n catch {\n happy = 'No one is clapping'\n}\n\nconsole.log(happy)\n```\n\n```\nNo one is clapping\n```\n\nBy setting our clapper number to zero, our `try...catch` statement returned the exception. When a script stops running due to an error we can leverage the code do something more than just dying.\n\n## Summary\n\nWe can use JavaScript statements to write programs to boss around the computer. We've covered some foundational statements here and I encourage you to play with them beyond our silly example. Beginning to grasp these statements makes me happy though, and we all deserve some claps for that.\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../inst/css/styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.37","pagetitle":"Maya Gans","title-block-banner":true,"title":"JavaScript Statements","author":"Maya Gans","date":"2019-08-02","description":"Statements aren't functions? Explaining the different and walking through some different JavaScript statements.","categories":["JavaScript"],"image":"featured.png"},"extensions":{"book":{"multiFile":true}}}}}