{"title":"Why Would I setTimeout(0)?","markdown":{"yaml":{"title":"Why Would I setTimeout(0)?","author":"Maya Gans","date":"2019-07-01","description":"Understanding asynchronous nature of JavaScript by setting the timeout to zero.","categories":["JavaScript"],"image":"featured.png"},"headingText":"CREATE BUTTON IN HTML","containsRefs":false,"markdown":"\n\n<iframe src=\"../../../files/button.html\" height = \"143px\" width = \"450 px\" align = \"center\"></iframe>\n\n<br></br>\n\nAlong with the hands-on skills I've been learning during my internship with RStudio, I've also been bolstering my theoretical understandings of programming concepts. This brought me to a common trick `setTimeout(0)`, which defers the execution of a function, giving something else a chance to run. \n\nThis concept was described using a concrete example in a [StackOverflow post](https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful) that I wanted to explore in more detail (both visually and without using JQuery):\n\n![](img1.png)\n\nYou want to create a button on your website with two tasks (1) perform a long calculation (2) and to print \"Calculating...\" in a div until \"Done!\" can be printed.\n\nFirst we'll create two buttons with small divs to see the status of the calculation\n```{html}\n<table border=1>\n  // our 'do' button will not use setTimeout\n  <tr><td><button id='do'>Do long calc - No Time Out</button></td>\n  // the default value in the div is 'Not Calculating yet'\n      <td><div id='status'>Not Calculating yet.</div></td>\n  </tr>\n  <tr><td><button id='do_ok'>Do long calc - Set Time Out 0</button></td>\n      <td><div id='status_ok'>Not Calculating yet.</div></td>\n  </tr>\n</table>\n```\n\n\n![](img3.png)\n\n## CREATE LONG FUNCTION\nCreate a function that takes a \"long time\" to run. When the function is done, it prints \"Done!\" to the div\n```{js}\nunction long_running(statusId) {\n        var result = 0;\n        for (var i = 0; i < 1000; i++) {\n          for (var j = 0; j < 700; j++) {\n            for (var k = 0; k < 300; k++) {\n              result = result + i + j + k;\n            }\n          }\n        }\n        status_update(statusId, `Done!`);\n      }\n```\n\n## CREATE STATUS UPDATE FUNCTION\n```{js}\nfunction status_update(statusId, message) {\n  document.getElementById(statusId).innerHTML = message;\n}\n```\n\n## PUT IT ALL TOGETHER\nUpdate the div by using an Event Listener. When clicking the button run our long calculation and the status update.\n```{js}\ndocument.getElementById(\"do\").addEventListener(\"click\", function() {\n  long_running(\"status\");\n  status_update(\"status\", \"calculating...\");\n});\n```\n\n## FAIL \nWithout using `setTimeout(0)` the queue of tasks that the button fires off are done serially: the long calculation \"locks\" the thread; the text *is* quickly set to \"Done!\" but the `status_update` function overwrites it with `calculating...`\n\n![](img2.png)\n\nUsing `setTimeout(0)` is a nifty trick to defer the actual long calculations until `status_update` has been executed. By setting a timeout if 0, you are queuing asynchronous code until the engine executes the current call stack.\n\n```{js}\ndocument.getElementById(\"do_ok\").addEventListener(\"click\", function() {\n  setTimeout(function() {\n    long_running(\"status_ok\");\n  }, 0);\n    status_update(\"status_ok\", \"calculating....\");\n});\n```\n\n**In the code chunk above the button text \"Not calculating yet\" will change to \"Calculating....\" and THEN \"Done!\"**\n\n## CONCLUSION \nJavaScript runtimes contain a message queue to store the list of messages to be processed (here \"calculating...\"). Because JavaScript is non-blocking, the messages can be queued in response to events (here: the long calculation). Using a simple **event loop** within our button, JavaScript enables the collection of asynchronous callbacks freeing the runtime to handle concurrent operations."},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../inst/css/styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.37","pagetitle":"Maya Gans","title-block-banner":true,"title":"Why Would I setTimeout(0)?","author":"Maya Gans","date":"2019-07-01","description":"Understanding asynchronous nature of JavaScript by setting the timeout to zero.","categories":["JavaScript"],"image":"featured.png"},"extensions":{"book":{"multiFile":true}}}}}