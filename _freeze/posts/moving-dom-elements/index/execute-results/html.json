{
  "hash": "53b3e7148ee4b7384d49aef638245826",
  "result": {
    "markdown": "---\ntitle: \"Moving DOM Elements in Shiny\"\nauthor: \"Maya Gans\"\ndate: '2022-02-15'\ndescription: \"A datatable case study to move around DOM elements in Shiny.\"\ncategories: [R, HTML, JavaScript]\nimage: \"featured.png\"\n---\n\n\nAs a Shiny web developer it's really common to leverage existing packages to create your HTML. But what if a package gets you 90% of where you want to go, and you want to customize it a little? \n\nIn this tutorial I give a default `DT` table a small makeover by combining the datatable's `dataTables_length` element and the datatables `dataTables_info element. *How did I find the names of these elements? The inspector!*\n\n![](before.png)\n\nMy goal is to combine these into a single element at the bottom of the table:\n\n![](after.png)\n\n## The Plan\n\nGiven the following Shiny app:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nui <- fluidPage(\n  DT::dataTableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  output$table <- DT::renderDataTable(\n    data.frame(cars),\n    rownames = FALSE,\n    # I want to scroll the y-axis \n    # so the table is always the same height\n    options = list(\n      scrollY = '50vh'\n    )\n  )\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\nWe need to: \n\n1) Store the select within `dataTables_length` as an object\n2) Create a new HTML element, `new_bottom` that we will use for our revamped `dataTables_info`\n3) Add the preamble text `Showing`\n4) Append the select dropdown from `dataTables_length` to the new element\n5) Add the total number of rows information in R\n6) Add the suffix text `entries`\n7) Replace `dataTables_info` with our new element\n8) Give the new element the `dataTables_info` class for styling\n9) Remove the `dataTables_length` node from the DOM\n\n## Implementation\n\nMy general workflow for applying JS to Shiny apps is to run the application and then actually do my manipulation in the browser's console. \n\n### Step 1\n\nUsing jQuery I stored the select dropdown to the object dropdown by finding the element of class `dataTables_length`, and then finding the `select` element inside it\n\n```js\nconst dropdown = $('.dataTables_length')\n                         .find('label')\n                         .find('select')\n\n```\n\n### Step 2 & 3\n\nNext I created a new DOM element, added the class `custom_dropdown` to make selecting the node easier, and added the prefix text `Showing`\n\n```js\nlet new_bottom = document.createElement('div')\nnew_bottom.classList.add('custom_dropdown')\nnew_bottom.innerHTML = 'Showing '\n```\n\n### Step 4 \n\nUsing jQuery's append function, we can add the isolated select to our new DOM element:\n\n```js\ndropdown.appendTo(new_bottom)\n```\n\n### Step 5 & 6\n\nAnd because we're writing JS as a string in R we can interpolate the `nrows` number to use in the suffix text `of 50 entries`\n\n```js\nnew_bottom.append(' of ' +\", nrow(cars), \" + ' entries')\n```\n\n### Step 7\n\nNow we can replace the existing element with our new custom one!\n\n```js\n$('.dataTables_info').replaceWith(new_bottom)\n```\n\n### Step 8\n\nWe can remove the custom class we added, and give it the class `dataTables_info` so that the same styling of the old element is applied to our new one. \n\n```js\n$('.custom_dropdown')\n    .removeClass('custom_dropdown')\n    .addClass('dataTables_info') \n```\n\n### Step 9\n\nAnd now we can remove the `dataTables_length` element from the DOM!\n\n```js\n$('.dataTables_length').remove()\n```\n\n## Putting it All Together\n\nThe DT function `renderDataTable` function has a `callback` argument, a function that is run once the table is rendered. We can apply our JS here as a string:\n\n```r\nlibrary(shiny)\n\nui <- fluidPage(\n  DT::dataTableOutput(\"table\")\n)\n\nserver <- function(input, output, session) {\n  output$table <- DT::renderDataTable(\n    data.frame(cars),\n    rownames = FALSE,\n    options = list(\n      scrollY = '50vh'\n    ),\n    callback = DT::JS(paste0(\"\n     const dropdown = $('.dataTables_length')\n                         .find('label')\n                         .find('select')\n\n     let new_bottom = document.createElement('div')\n     new_bottom.classList.add('custom_dropdown')\n     new_bottom.innerHTML = 'Showing '\n     \n     dropdown.appendTo(new_bottom)\n                      \n     new_bottom.append(' of ' +\", nrow(cars), \" + ' entries')\n                      \n     $('.dataTables_info')\n          .replaceWith(new_bottom)\n                           \n     $('.custom_dropdown')\n         .removeClass('custom_dropdown')\n         .addClass('dataTables_info') \n                         \n     $('.dataTables_length').remove()\"))\n  )\n}\n\nshinyApp(ui, server)\n```\n\nEt Viola! It's a small UI fix that makes a world of difference! \n\nI leverage jQuery here a LOT because Shiny is already loading the library, but vanilla JS can do **all** of this now. I'm hoping to refactor this code to get more familiar with vanilla JS DOM manipulation: stay tuned for more! \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}