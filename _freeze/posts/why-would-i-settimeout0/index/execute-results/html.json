{
  "hash": "046e27e1a2d91db8b5130aad3c7a39be",
  "result": {
    "markdown": "---\ntitle: \"Why Would I setTimeout(0)?\"\nauthor: \"Maya Gans\"\ndate: '2019-08-14'\ndescription: \"Trying to understand the weird world of async javascript\"\ncategories: [JavaScript]\nimage: \"featured.png\"\nformat:\n  html:\n    css: style.css\n    include-in-header: \n      text: <script src=\"./script.js\"></script>\n---\n\n\n<div class=\"table-container\">\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<table border=\"1\">\n<tr>\n<td>\n<button id=\"do\" class=\"examplebtn\" onclick=\"doBtn()\">Do long calc - No Time Out</button>\n</td>\n<td>\n<div id=\"status\">Not Calculating yet.</div>\n</td>\n</tr>\n<tr>\n<td>\n<button id=\"do_ok\" class=\"examplebtn\" onClick=\"doOkBtn()\">Do long calc - Time Out</button>\n</td>\n<td>\n<div id=\"status_ok\">Not Calculating yet.</div>\n</td>\n</tr>\n</table>\n```\n:::\n:::\n\n</div>\n\nAlong with the hands-on skills I've been learning during my internship with RStudio, I've also been bolstering my theoretical understandings of programming concepts. This brought me to a common trick `setTimeout(0)`, which defers the execution of a function, giving something else a chance to run. \n\nThis concept was described using a concrete example in a [StackOverflow post](https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful) that I wanted to explore in more detail (both visually and without using JQuery):\n\n![](img1.png)\n\nYou want to create a button on your website with two tasks (1) perform a long calculation (2) and to print \"Calculating...\" in a div until \"Done!\" can be printed.\n\n## CREATE BUTTON IN HTML\nFirst we'll create two buttons with `div` outputs to see the status of the calculation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtmltools::tags$table(border=1,\n  htmltools::tags$tr(\n    htmltools::tags$td(\n      htmltools::tags$button(\n        id =\"do\",\n        \"Do long calc - No Time Out\"\n      )\n    ),\n    htmltools::tags$td(\n      htmltools::tags$div(\n        id =\"status\",\n        \"Not Calculating yet.\"\n      )\n    )\n  ),\n    htmltools::tags$tr(\n    htmltools::tags$td(\n      htmltools::tags$button(\n        id =\"do_ok\",\n        \"Do long calc - Time Out\"\n      )\n    ),\n    htmltools::tags$td(\n      htmltools::tags$div(\n        id =\"status_ok\",\n        \"Not Calculating yet.\"\n      )\n    )\n  )\n)\n```\n:::\n\n\n\n![](img3.png)\n\n## CREATE LONG FUNCTION\nCreate a function that takes a \"long time\" to run. When the function is done, it prints \"Done!\" to the div\n\n```js\nfunction long_running(statusId) {\n  var result = 0;\n  for (var i = 0; i < 1000; i++) {\n    for (var j = 0; j < 700; j++) {\n      for (var k = 0; k < 300; k++) {\n        result = result + i + j + k;\n      }\n    }\n  }\n  status_update(statusId, `Done!`);\n}\n```\n\n## CREATE STATUS UPDATE FUNCTION\n\n```js\nfunction status_update(statusId, message) {\n  document.getElementById(statusId).innerHTML = message;\n}\n```\n\n## PUT IT ALL TOGETHER\nUpdate the div by using an Event Listener. When clicking the button run our long calculation and the status update.\n\n```js\ndocument.getElementById(\"do\").addEventListener(\"click\", function() {\n  long_running(\"status\");\n  status_update(\"status\", \"calculating...\");\n});\n```\n\n## FAIL \n\nWithout using `setTimeout(0)` the queue of tasks that the button fires off are done serially: the long calculation \"locks\" the thread; the text *is* quickly set to \"Done!\" but the `status_update` function overwrites it with `calculating...`\n\n![](img2.png)\n\nUsing `setTimeout(0)` is a nifty trick to defer the actual long calculations until `status_update` has been executed. By setting a timeout if 0, you are queuing asynchronous code until the engine executes the current call stack.\n\n```js\ndocument.getElementById(\"do_ok\").addEventListener(\"click\", function() {\n  setTimeout(function() {\n    long_running(\"status_ok\");\n  }, 0);\n    status_update(\"status_ok\", \"calculating....\");\n});\n```\n\n**In the code chunk above the button text \"Not calculating yet\" will change to \"Calculating....\" and THEN \"Done!\"**\n\n## CONCLUSION \nJavaScript runtimes contain a message queue to store the list of messages to be processed (here \"calculating...\"). Because JavaScript is non-blocking, the messages can be queued in response to events (here: the long calculation). Using a simple **event loop** within our button, JavaScript enables the collection of asynchronous callbacks freeing the runtime to handle concurrent operations.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}