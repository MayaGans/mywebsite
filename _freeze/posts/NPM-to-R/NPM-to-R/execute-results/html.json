{
  "hash": "44e88558036720bbda5c42319cd10cb3",
  "result": {
    "markdown": "---\ntitle: \"NPM to R!\"\nauthor: \"Maya Gans\"\ndate: '2022-08-19'\ndescription: \"Making my first NPM library to use in Observable (and R!)\"\ncategories: [JavaScript, R]\nimage: \"featured.png\"\n---\n\n\nI've seen for people to import stuff into Observable notebooks using the notation: \n\n```js\nlet maya_utils = require(\"maya_utils\")\n```\n\nWhich I've essentially learned means `library(\"maya_utils\")` in R notation. I've made lots of `R` packages, but I've always wanted to learn how to make a JS library and publish it on `NPM` (basically JS's `CRAN` but without any review), and then use the library in Observable (and now R via Quarto!)\n\n## Steps:\n\n1. Create an NPM registry account\n2. Write some code\n3. Export your module\n4. Write some more code\n5. Combine functions in index.js\n6. Bundle\n7. Test with `mocha`\n8. Publish the library\n9. Use in Observable (And R!)\n\n## Step 1 Create an NPM registry account \n[Make an NPM account](https://www.npmjs.com/) by signing up!\n\n## Step 2 Write some code\n\nI created a folder called `maya_utils`, opened VSCode (sorry RStudio) and navigated to the terminal to initialize my `package.json` with the defaults (you can totally change these later):\n\n```js\nnpm init -y\n```\n\nOpen the package.json file: \n\n```js\n{\n  \"name\": \"maya_utils\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\nThe file named in the main key, `index.js` in this case, will be the entry point in to your package after a user installs it. **It will be what you export from this file that will give the user functionality once they have installed the package.**\n\nNow create a folder called `src` and within it a file called `removeDuplicates.js` and we'll put a single function in there, the code to remove duplicates:\n\n```js\nlet uniqueArr = []\nfunction removeDuplicates(arr){\n\n  // Accepts an array from which the duplicates\n  // will be removed\n  if (!Array.isArray(arr)){\n    arr = []\n  }\n\n  let theSet = new Set(arr)\n  let uniqueArr = [...theSet]\n\n  return uniqueArr\n}\n```\n\nNow we're going to add another file called `index.js` inside the `src` folder with the code:\n\n```js\nimport removeDuplicates from './removeArrayDuplicates';\n\nexport{\n  removeDuplicates\n}\n```\n\n## Step 3 Export functions\n\nIn `R` we need to `source(file_name)` in a script to expose that script to another file. In JavaScript we do this using ES6 module notation. In order to use the function `removeDuplicates` in other files we need to `export` it:\n\n```js\nexport default function removeDuplicates(arr) {\n```\n\n## Step 4: A second function!\n\nIn our `src` folder create a function called pluck to get the values for a key: \n\n```js\nexport default function pluck(key, array) {\n  return array.reduce((values, current) => {\n    values.push(current[key]);\n\n    return values;\n  }, [])\n}\n```\n\n## Step 5 Combine functions in index.js\n\nNow we can create a file called `index.js` at the root level of our folder structure and within in export all the functions we want exposed to users. We can use the `import` function to grab the functions from their respective files. By exporting them here we're essentially doing the same thing as a roxygen `@export`, exposing the functions to end users.\n\n```js\nimport removeDuplicates from \"./src/removeDuplicates\"\nimport pluck from \"./src/pluck\"\n\nexport {\n  removeDuplicates,\n  pluck\n}\n```\n\n## Step 6: Bundle!\n\nThis was the most intimidating step for me because bundling and compiling JS code gives me a lot of imposter syndrome! Here's an attempt to explain:\n\nIn order to use all the functions in the library within index.js we need to bundle all our code. This example has code in three files so far, `replaceDuplicates.js`, `pluck.js` and it's collated in `index.js`. A bundler will take all the code and put it in one file for you! \n\n`esbuild` is the new hotness let's use this in the terminal to send our bundled output into a file called `out.js`\n\n```js\nnpm install esbuild\n./node_modules/.bin/esbuild index.js --bundle --outfile=out.js\n```\n\nto bundle our code we run `npm run build` and you'll see a file `out.js` is generated!\n\n## Step 7 Test your function\n\nWe're going to use the mocha library for testing our functions since I really like that it looks and feels like `{testthat}`\n\n```js\nnpm install --global mocha\n```\n\nWe'll also use this helper library `mocha-esbuild` to be able to use modules inside our tests, grabbing the functions from their original files.\n\n```js\nnpm i --save-dev @rtvision/mocha-esbuild\n```\n\nBack in your `package.json` you want to change the script so that when we run `npm test` it runs the mocha function from `mocha-esbuild` and builds all the testing files inside our testing folder: \n```js\n\"scripts\": {\n  \"test\": \"npx mocha-esbuild \\\"test/**.js\\\"\"\n}\n```\n\nWe're also going to use `chai` because Node has built in `assert` functionality but we want to be able to use that in a more extensible way:\n\n```js\nnpm i --save-dev chai\n```\n\nWithin a folder called test we'll make a file called `test_removeDuplicates` and another called `test_pluck`. This is to demonstrate testing in multiple files but we could have just as well combined the tests in a single file!\n\nHere's `test_removeDuplicates`\n```js\n'use strict'\n\nvar assert = require('chai').assert;\nimport removeDuplicates from \"../src/removeDuplicates.js\"\n\ndescribe('suite of utility functions inside removeDuplicates', function () {\n  describe('removing array duplicates', function () {\n    it('should return unique values', function () {\n        let myNums = [1,2,3,1,4,1,2,5,3,4];\n        assert.deepEqual([1, 2, 3, 4, 5], removeDuplicates(myNums));\n      });\n  });\n})\n```\n\nAnd here is `test_pluck`\n\n```js\n'use strict'\n\nvar assert = require('chai').assert;\nimport pluck from \"../src/pluck.js\"\n\ndescribe('suite of utility functions inside pluck', function () {\n  describe('get all values in array of objects given a key', function () {\n    it('should return unique values', function () {\n        let myObj = [{name: 'Maya'}, {name: 'Jordan'}];\n        assert.deepEqual(['Maya', 'Jordan'], pluck('name', myObj));\n      });\n  });\n})\n```\n\nNow you can run `npm test` in the terminal you should see this output:\n\n```js\n> npx mocha-esbuild \"test/**.js\"\n\nConfig processed, starting esbuild\nBuild was successful, running tests\n\n\n  suite of utility functions inside pluck\n    get all values in array of objects given a key\n      ✔ should return unique values\n\n  suite of utility functions inside removeDuplicates\n    removing array duplicates\n      ✔ should return unique values\n\n\n  2 passing (5ms)\n```\n\nWoohoo our tests passed!\n\n## Step 7: Publish your package to the NPM registry\n\nLogin to npm using the command in the terminal \n\n```js\nnpm login\n```\n\nFollow the prompts to enter your username, password, email, and two factor identification. Then register using:\n\n```js\nnpm register\n```\n\nYou should get a notification in the terminal as well as an email confirming the success of your build.\n\n## Step 8: Use in Observable! And R!\n\nNow for the fun part! We can import our module into an Observable chunk using the following Skypack code. I knew to do this from [this incredible notebook](https://observablehq.com/@observablehq/module-require-debugger) where you can input an NPM library (`maya_utils`) it shows you all your options for importing into Observable!\n\n\n```{ojs}\nmaya_utils = import('https://unpkg.com/maya_utils@1.1.0/index.js?module')\n```\n\n\n:::twitter\nNote my version is 1.1.0, I made a lot of mistakes and edits before finally getting this published!!\n:::\n\nNow we can access the `removeDuplicates` function and `pluck` function by prefixing with the library name (kind of like `maya_utils::function_name`)\n\n\n```{ojs}\nmaya_utils.removeDuplicates([1,2,2,3,4,5,6,6])\n```\n\n```{ojs}\nmaya_utils.pluck('name', [{name: 'Batman'}, {name: 'Robin'}])\n```\n\n\nBut the coolest part? With Quarto I can pass in R DATA INTO MY JAVASCRIPT LIBRARY?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_array <- round(rnorm(5, 20))\nojs_define(r_array)\n```\n:::\n\n```{ojs}\nmaya_utils.removeDuplicates(r_array)\n```\n\n\nWOULD YOU LOOK AT THAT?! ITS A THING OF BEAUTY! From JS to Observable to R! And we can even pass a `reactive` to our function when the Quarto document is of type Shiny! \n\nIt's probably helpful to see the whole thing all together. Here's [my repo of utility functions](https://github.com/MayaGans/maya_utils), and a [link to NPM](https://www.npmjs.com/package/maya_utils)!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script type=\"ojs-define\">\n{\"contents\":[{\"name\":\"r_array\",\"value\":[17,18,21,20,18]}]}\n</script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}